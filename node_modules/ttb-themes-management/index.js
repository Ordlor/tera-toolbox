"use strict";

const fs = require('fs');
const path = require('path');

const pathJoin = (...args) => {
	return path.join(...args);
};

const checkIsCssAvailable = (path) => {
	if (!path.endsWith(".css")) return false;
	if (!fs.statSync(path).isFile()) return false;

	return true;
};

const listAvailableThemes = (rootFolder) => {
	let names = [];
	if (!fs.existsSync(rootFolder))
		return;

	(fs.readdirSync(rootFolder)).forEach(name => {
		console.log(name)
		if (!(name[0] === ".") && !(name[0] === "_") && (fs.statSync(path.join(rootFolder, name)).isDirectory())) {
			names.push(name);
		}
	})

	return names;
}

const loadThemeInfo = (rootFolder, name) => {
	const themePath = path.join(rootFolder, name);

	let result = {
		name: name.toLowerCase(),
		path: themePath,
		author: null,
		description: null,
		version: null,
		entryPoint: null
	};

	let themeInfo = null;
	try {
		themeInfo = fs.readFileSync(pathJoin(themePath, 'theme.json'), 'utf8');
	} catch (_) {
		return null;
	}

	if (themeInfo) {
		themeInfo = JSON.parse(themeInfo);

		if (!themeInfo.entryPoint || themeInfo.entryPoint.length === 0) return null;
		themeInfo.entryPoint = path.resolve(pathJoin(themePath, themeInfo.entryPoint));
		if (!checkIsCssAvailable(themeInfo.entryPoint)) return null;

		Object.assign(result, {
			name: (themeInfo.name || result.name).toLowerCase(),
			author: themeInfo.author || result.author,
			description: themeInfo.description || result.description,
			version: themeInfo.version || result.version,
			entryPoint: themeInfo.entryPoint
		});
	}
	else {
		return null;
	}

	return result;
}

exports.listThemes = (rootFolder) => {
	let result = {};
	let list = listAvailableThemes(rootFolder);
	list.forEach(name => {
		let info = loadThemeInfo(rootFolder, name);
		if(info) result[name] = info;
	})
	return result;
}